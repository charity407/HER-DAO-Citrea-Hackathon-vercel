"use client"

/** ----------  Types  ---------- */
export interface CertificateMetadata {
  name: string
  description: string
  image: string
  attributes: Array<{ trait_type: string; value: string | number }>
  external_url: string
}

export interface StoredCertificate {
  id: string
  userId: string
  moduleId: string
  zkProofHash: string
  txHash: string
  metadata: CertificateMetadata
  mintedAt: string
  verified: boolean
}

/** ----------  Storage Class  ---------- */
class CertificateStorage {
  /* Existing caches */
  private certificates: Map<string, StoredCertificate> = new Map()
  /* NEW: cache for ZK-proof metadata */
  private proofMetadata: Map<string, any> = new Map()

  /* ----------------  Certificates  ---------------- */

  async storeCertificate(certificate: StoredCertificate): Promise<void> {
    this.certificates.set(certificate.id, certificate)

    // persist to localStorage for demo
    const stored = JSON.parse(localStorage.getItem("zkCertificates") || "[]")
    stored.push(certificate)
    localStorage.setItem("zkCertificates", JSON.stringify(stored))

    console.log("Certificate stored:", certificate.id)
  }

  async getCertificate(certificateId: string): Promise<StoredCertificate | null> {
    // memory cache
    if (this.certificates.has(certificateId)) return this.certificates.get(certificateId)!

    // localStorage fallback
    const stored = JSON.parse(localStorage.getItem("zkCertificates") || "[]")
    const cert = stored.find((c: StoredCertificate) => c.id === certificateId) || null
    if (cert) this.certificates.set(certificateId, cert)
    return cert
  }

  async getUserCertificates(userId: string): Promise<StoredCertificate[]> {
    const stored = JSON.parse(localStorage.getItem("zkCertificates") || "[]")
    const certs = stored.filter((c: StoredCertificate) => c.userId === userId)
    certs.forEach((c: StoredCertificate) => this.certificates.set(c.id, c))
    return certs.sort((a, b) => new Date(b.mintedAt).getTime() - new Date(a.mintedAt).getTime())
  }

  /* ----------------  IPFS helpers (mocked)  ---------------- */

  async uploadToIPFS(data: any): Promise<string> {
    // mock: pretend to upload and return fake hash
    await new Promise((r) => setTimeout(r, 1000))
    return `Qm${Math.random().toString(36).slice(2, 44)}`
  }

  async generateCertificateImage(metadata: CertificateMetadata): Promise<string> {
    const hash = await this.uploadToIPFS({ type: "certificate_image", metadata })
    return `ipfs://${hash}`
  }

  /* ----------------  NEW: Proof Metadata  ---------------- */

  /**
   * Persists ZK-proof metadata generated by the Citrea SDK.
   * In production youâ€™d store this on IPFS or a DB;
   * here we cache in-memory + localStorage so it survives refresh.
   */
  async storeProofMetadata(zkProof: any, certData: any): Promise<void> {
    try {
      const key = zkProof.proof || crypto.randomUUID?.() || Math.random().toString(36).slice(2)
      const payload = { key, zkProof, certData, storedAt: new Date().toISOString() }

      // in-memory
      this.proofMetadata.set(key, payload)

      // localStorage backup
      const saved = JSON.parse(localStorage.getItem("zkProofMetadata") || "[]")
      saved.push(payload)
      localStorage.setItem("zkProofMetadata", JSON.stringify(saved))

      console.log("Proof metadata stored:", key)
    } catch (err) {
      console.error("Failed to store proof metadata:", err)
    }
  }
}

/** ----------  Singleton Accessor  ---------- */
let certificateStorage: CertificateStorage | null = null
export const getCertificateStorage = (): CertificateStorage => {
  if (!certificateStorage) certificateStorage = new CertificateStorage()
  return certificateStorage
}

/** ----------  Helpers  ---------- */
export const formatCertificateId = (id: string): string =>
  id.length <= 16 ? id : `${id.slice(0, 8)}...${id.slice(-8)}`

export const getCertificateShareUrl = (certificateId: string): string =>
  `${window.location.origin}/certificates/${certificateId}`

export const downloadCertificateMetadata = (certificate: StoredCertificate): void => {
  const blob = new Blob([JSON.stringify(certificate, null, 2)], { type: "application/json" })
  const url = URL.createObjectURL(blob)
  const link = document.createElement("a")
  link.href = url
  link.download = `zkCert_${certificate.id}.json`
  link.click()
  URL.revokeObjectURL(url)
}
